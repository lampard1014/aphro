// Code generated by protoc-gen-go. DO NOT EDIT.
// source: redis.proto

/*
Package Aphro_Redis_pb is a generated protocol buffer package.

It is generated from these files:
	redis.proto

It has these top-level messages:
	ExpireAtRequest
	ExpireAtResponse
	IsExistsRequest
	IsExistsResponse
	QueryRedisRequest
	QueryRedisResponse
	DeleteRedisRequest
	DeleteRedisResponse
	SetRedisRequest
	SetRedisResponse
*/
package Aphro_Redis_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ExpireAtRequest struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Ttl uint64 `protobuf:"varint,2,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *ExpireAtRequest) Reset()                    { *m = ExpireAtRequest{} }
func (m *ExpireAtRequest) String() string            { return proto.CompactTextString(m) }
func (*ExpireAtRequest) ProtoMessage()               {}
func (*ExpireAtRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ExpireAtRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ExpireAtRequest) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type ExpireAtResponse struct {
	Successed bool `protobuf:"varint,1,opt,name=successed" json:"successed,omitempty"`
}

func (m *ExpireAtResponse) Reset()                    { *m = ExpireAtResponse{} }
func (m *ExpireAtResponse) String() string            { return proto.CompactTextString(m) }
func (*ExpireAtResponse) ProtoMessage()               {}
func (*ExpireAtResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ExpireAtResponse) GetSuccessed() bool {
	if m != nil {
		return m.Successed
	}
	return false
}

type IsExistsRequest struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *IsExistsRequest) Reset()                    { *m = IsExistsRequest{} }
func (m *IsExistsRequest) String() string            { return proto.CompactTextString(m) }
func (*IsExistsRequest) ProtoMessage()               {}
func (*IsExistsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *IsExistsRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type IsExistsResponse struct {
	IsExists bool `protobuf:"varint,1,opt,name=isExists" json:"isExists,omitempty"`
}

func (m *IsExistsResponse) Reset()                    { *m = IsExistsResponse{} }
func (m *IsExistsResponse) String() string            { return proto.CompactTextString(m) }
func (*IsExistsResponse) ProtoMessage()               {}
func (*IsExistsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IsExistsResponse) GetIsExists() bool {
	if m != nil {
		return m.IsExists
	}
	return false
}

type QueryRedisRequest struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *QueryRedisRequest) Reset()                    { *m = QueryRedisRequest{} }
func (m *QueryRedisRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRedisRequest) ProtoMessage()               {}
func (*QueryRedisRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueryRedisRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type QueryRedisResponse struct {
	Successed bool   `protobuf:"varint,1,opt,name=successed" json:"successed,omitempty"`
	Value     string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *QueryRedisResponse) Reset()                    { *m = QueryRedisResponse{} }
func (m *QueryRedisResponse) String() string            { return proto.CompactTextString(m) }
func (*QueryRedisResponse) ProtoMessage()               {}
func (*QueryRedisResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *QueryRedisResponse) GetSuccessed() bool {
	if m != nil {
		return m.Successed
	}
	return false
}

func (m *QueryRedisResponse) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DeleteRedisRequest struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteRedisRequest) Reset()                    { *m = DeleteRedisRequest{} }
func (m *DeleteRedisRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRedisRequest) ProtoMessage()               {}
func (*DeleteRedisRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteRedisRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeleteRedisResponse struct {
	Successed bool `protobuf:"varint,1,opt,name=successed" json:"successed,omitempty"`
}

func (m *DeleteRedisResponse) Reset()                    { *m = DeleteRedisResponse{} }
func (m *DeleteRedisResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteRedisResponse) ProtoMessage()               {}
func (*DeleteRedisResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DeleteRedisResponse) GetSuccessed() bool {
	if m != nil {
		return m.Successed
	}
	return false
}

type SetRedisRequest struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Ttl   uint64 `protobuf:"varint,3,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *SetRedisRequest) Reset()                    { *m = SetRedisRequest{} }
func (m *SetRedisRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRedisRequest) ProtoMessage()               {}
func (*SetRedisRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SetRedisRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetRedisRequest) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *SetRedisRequest) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type SetRedisResponse struct {
	Successed bool `protobuf:"varint,1,opt,name=successed" json:"successed,omitempty"`
}

func (m *SetRedisResponse) Reset()                    { *m = SetRedisResponse{} }
func (m *SetRedisResponse) String() string            { return proto.CompactTextString(m) }
func (*SetRedisResponse) ProtoMessage()               {}
func (*SetRedisResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SetRedisResponse) GetSuccessed() bool {
	if m != nil {
		return m.Successed
	}
	return false
}

func init() {
	proto.RegisterType((*ExpireAtRequest)(nil), "Aphro.Redis.pb.expireAtRequest")
	proto.RegisterType((*ExpireAtResponse)(nil), "Aphro.Redis.pb.expireAtResponse")
	proto.RegisterType((*IsExistsRequest)(nil), "Aphro.Redis.pb.isExistsRequest")
	proto.RegisterType((*IsExistsResponse)(nil), "Aphro.Redis.pb.isExistsResponse")
	proto.RegisterType((*QueryRedisRequest)(nil), "Aphro.Redis.pb.queryRedisRequest")
	proto.RegisterType((*QueryRedisResponse)(nil), "Aphro.Redis.pb.queryRedisResponse")
	proto.RegisterType((*DeleteRedisRequest)(nil), "Aphro.Redis.pb.deleteRedisRequest")
	proto.RegisterType((*DeleteRedisResponse)(nil), "Aphro.Redis.pb.deleteRedisResponse")
	proto.RegisterType((*SetRedisRequest)(nil), "Aphro.Redis.pb.setRedisRequest")
	proto.RegisterType((*SetRedisResponse)(nil), "Aphro.Redis.pb.setRedisResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RedisService service

type RedisServiceClient interface {
	// query create delete update Redis
	IsExists(ctx context.Context, in *IsExistsRequest, opts ...grpc.CallOption) (*IsExistsResponse, error)
	ExpireAt(ctx context.Context, in *ExpireAtRequest, opts ...grpc.CallOption) (*ExpireAtResponse, error)
	Query(ctx context.Context, in *QueryRedisRequest, opts ...grpc.CallOption) (*QueryRedisResponse, error)
	Delete(ctx context.Context, in *DeleteRedisRequest, opts ...grpc.CallOption) (*DeleteRedisResponse, error)
	Set(ctx context.Context, in *SetRedisRequest, opts ...grpc.CallOption) (*SetRedisResponse, error)
}

type redisServiceClient struct {
	cc *grpc.ClientConn
}

func NewRedisServiceClient(cc *grpc.ClientConn) RedisServiceClient {
	return &redisServiceClient{cc}
}

func (c *redisServiceClient) IsExists(ctx context.Context, in *IsExistsRequest, opts ...grpc.CallOption) (*IsExistsResponse, error) {
	out := new(IsExistsResponse)
	err := grpc.Invoke(ctx, "/Aphro.Redis.pb.RedisService/isExists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redisServiceClient) ExpireAt(ctx context.Context, in *ExpireAtRequest, opts ...grpc.CallOption) (*ExpireAtResponse, error) {
	out := new(ExpireAtResponse)
	err := grpc.Invoke(ctx, "/Aphro.Redis.pb.RedisService/expireAt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redisServiceClient) Query(ctx context.Context, in *QueryRedisRequest, opts ...grpc.CallOption) (*QueryRedisResponse, error) {
	out := new(QueryRedisResponse)
	err := grpc.Invoke(ctx, "/Aphro.Redis.pb.RedisService/query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redisServiceClient) Delete(ctx context.Context, in *DeleteRedisRequest, opts ...grpc.CallOption) (*DeleteRedisResponse, error) {
	out := new(DeleteRedisResponse)
	err := grpc.Invoke(ctx, "/Aphro.Redis.pb.RedisService/delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *redisServiceClient) Set(ctx context.Context, in *SetRedisRequest, opts ...grpc.CallOption) (*SetRedisResponse, error) {
	out := new(SetRedisResponse)
	err := grpc.Invoke(ctx, "/Aphro.Redis.pb.RedisService/set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RedisService service

type RedisServiceServer interface {
	// query create delete update Redis
	IsExists(context.Context, *IsExistsRequest) (*IsExistsResponse, error)
	ExpireAt(context.Context, *ExpireAtRequest) (*ExpireAtResponse, error)
	Query(context.Context, *QueryRedisRequest) (*QueryRedisResponse, error)
	Delete(context.Context, *DeleteRedisRequest) (*DeleteRedisResponse, error)
	Set(context.Context, *SetRedisRequest) (*SetRedisResponse, error)
}

func RegisterRedisServiceServer(s *grpc.Server, srv RedisServiceServer) {
	s.RegisterService(&_RedisService_serviceDesc, srv)
}

func _RedisService_IsExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedisServiceServer).IsExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aphro.Redis.pb.RedisService/IsExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedisServiceServer).IsExists(ctx, req.(*IsExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RedisService_ExpireAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpireAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedisServiceServer).ExpireAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aphro.Redis.pb.RedisService/ExpireAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedisServiceServer).ExpireAt(ctx, req.(*ExpireAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RedisService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRedisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedisServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aphro.Redis.pb.RedisService/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedisServiceServer).Query(ctx, req.(*QueryRedisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RedisService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRedisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedisServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aphro.Redis.pb.RedisService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedisServiceServer).Delete(ctx, req.(*DeleteRedisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RedisService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRedisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RedisServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aphro.Redis.pb.RedisService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RedisServiceServer).Set(ctx, req.(*SetRedisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RedisService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Aphro.Redis.pb.RedisService",
	HandlerType: (*RedisServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "isExists",
			Handler:    _RedisService_IsExists_Handler,
		},
		{
			MethodName: "expireAt",
			Handler:    _RedisService_ExpireAt_Handler,
		},
		{
			MethodName: "query",
			Handler:    _RedisService_Query_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _RedisService_Delete_Handler,
		},
		{
			MethodName: "set",
			Handler:    _RedisService_Set_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "redis.proto",
}

func init() { proto.RegisterFile("redis.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xd1, 0x4e, 0xfa, 0x30,
	0x14, 0xc6, 0xe1, 0xbf, 0x3f, 0x04, 0x8e, 0x46, 0xb0, 0x7a, 0x41, 0x16, 0x12, 0xb1, 0x44, 0xc3,
	0xd5, 0x30, 0x12, 0x1f, 0x80, 0x0b, 0x13, 0xa3, 0x17, 0x9a, 0xf1, 0x04, 0x03, 0x4e, 0xb0, 0x71,
	0x59, 0xc7, 0x4e, 0x47, 0xe0, 0x79, 0x7c, 0x51, 0xb3, 0x0e, 0x98, 0xb4, 0x80, 0xdc, 0xb5, 0x27,
	0x5f, 0x7f, 0xa7, 0xa7, 0xdf, 0x57, 0x38, 0x4b, 0x70, 0x2a, 0xc8, 0x8b, 0x13, 0xa9, 0x24, 0xbb,
	0x18, 0xc6, 0x9f, 0x89, 0xf4, 0xfc, 0xbc, 0x34, 0x76, 0xdb, 0x33, 0x29, 0x67, 0x21, 0xf6, 0x83,
	0x58, 0xf4, 0x83, 0x28, 0x92, 0x2a, 0x50, 0x42, 0x46, 0x6b, 0x35, 0x7f, 0x82, 0x06, 0x2e, 0x63,
	0x91, 0xe0, 0x50, 0xf9, 0x38, 0x4f, 0x91, 0x14, 0x6b, 0x82, 0xf3, 0x85, 0xab, 0x56, 0xb9, 0x53,
	0xee, 0xd5, 0xfd, 0x6c, 0x99, 0x55, 0x94, 0x0a, 0x5b, 0xff, 0x3a, 0xe5, 0xde, 0x7f, 0x3f, 0x5b,
	0xf2, 0x07, 0x68, 0x16, 0xc7, 0x28, 0x96, 0x11, 0x21, 0x6b, 0x43, 0x9d, 0xd2, 0xc9, 0x04, 0x89,
	0x70, 0xaa, 0x4f, 0xd7, 0xfc, 0xa2, 0xc0, 0xbb, 0xd0, 0x10, 0xf4, 0xbc, 0x14, 0xa4, 0xe8, 0x60,
	0x23, 0xee, 0x41, 0xb3, 0x10, 0xad, 0xb1, 0x2e, 0xd4, 0x36, 0xb5, 0x35, 0x75, 0xbb, 0xe7, 0x77,
	0x70, 0x39, 0x4f, 0x31, 0x59, 0xe9, 0x61, 0x0f, 0x63, 0x5f, 0x80, 0xfd, 0x96, 0x9d, 0x72, 0x5f,
	0x76, 0x0d, 0x95, 0x45, 0x10, 0xa6, 0xa8, 0xa7, 0xae, 0xfb, 0xf9, 0x86, 0xdf, 0x03, 0x9b, 0x62,
	0x88, 0x0a, 0xff, 0xe8, 0x38, 0x80, 0xab, 0x1d, 0xdd, 0x49, 0x4f, 0xf4, 0x06, 0x0d, 0x42, 0x75,
	0x9c, 0xbc, 0xff, 0x5e, 0x1b, 0x87, 0x9c, 0x1d, 0x87, 0x0a, 0xd8, 0x29, 0xed, 0x1f, 0xbf, 0x1d,
	0x38, 0xd7, 0xfa, 0x11, 0x26, 0x0b, 0x31, 0x41, 0xf6, 0x5e, 0xbc, 0x3c, 0xbb, 0xf1, 0x76, 0x63,
	0xe5, 0x19, 0x66, 0xba, 0x9d, 0xc3, 0x82, 0xbc, 0x3b, 0x2f, 0x65, 0xc0, 0x4d, 0x6a, 0x6c, 0xa0,
	0x11, 0x43, 0x1b, 0x68, 0x06, 0x8e, 0x97, 0xd8, 0x07, 0x54, 0xb4, 0xb1, 0xec, 0xd6, 0x14, 0x5b,
	0xb1, 0x70, 0xf9, 0x31, 0xc9, 0x96, 0x38, 0x82, 0x6a, 0x6e, 0x1c, 0xb3, 0xf4, 0xb6, 0xf1, 0x6e,
	0xf7, 0xa8, 0x66, 0x0b, 0x7d, 0x05, 0x87, 0x70, 0xcf, 0xc8, 0x86, 0xdb, 0xf6, 0xc8, 0xa6, 0x83,
	0xbc, 0x34, 0xae, 0xea, 0x7f, 0x3b, 0xf8, 0x09, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xbc, 0x88, 0xd0,
	0xf4, 0x03, 0x00, 0x00,
}
